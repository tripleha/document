# linux 内存管理机制学习

(主要根据 32 位系统来学习)

- 分页与虚拟地址
    以字节为最小访问单位， 32 位地址理论上可以寻址 2<sup>32</sup>B(4GB) 的空间。不过这样虚拟地址和物理地址一一对应的话就要花费大量空间来存对应的映射关系，也缺乏连续性。所以采用分页的做法，将 32 位地址中的一部分低位数作为偏移的做法，这样将满足低位偏移确定空间大小作为一个页的大小，这样需要索引的只有页的首地址，接下来的页内偏移是虚拟地址和物理地址公用的。每页内存必须是连续的，才能使用偏移在页内定位。一般用的是12位的页内偏移。这样 4GB 的内存就被切成了一块块 2<sup>12</sup>B(4KB) 大小的空间。这样一共有 2<sup>20</sup> 个页。假设每个条目占用4字节(一个地址)，则需要 4MB(2<sup>22</sup>B) 的连续物理内存空间存储页表映，地址前20位是页表中偏移(页号)。而且是对于单个进程而言，因为每个进程是不一样的，所以每个进程都需要 4MB 页表空间。这样的内存占用显然是不可以接受的。于是有了多级页表。
    - 多级页表
        我们对页号再做一层切分，分成两级页表，那么前十位对应一级页表的偏移，后十位对应二级页表的偏移，则我们一刚开始只需要 2<sup>12</sup>B (4KB) 的空间就可以了，然后根据需要的内存，再增加二级页表的数量，一共可以有 2<sup>10</sup> 个二级页表。总共可以映射 4GB 内存。那么我们就只需要一级页表的首地址，就可以解析任何一个虚拟地址了。
        |一级页号|二级页号|页内偏移|
        |--|--|--|
        |10位|10位|12位|
        - TLB(Translation Lookaside Buffer)
            多级页表下的一层缓存优化，又叫快表。如果虚拟地址在 TLB 中，则可以一步获得对应物理地址。

- 多任务系统下单个进程的用户空间(分段)
    linux 为了方便管理进程虚拟内存空间，划分内存空间功能，将内存分成一个个段，按段划分功能。
    用户空间由低地址到高地址分为:
    - 代码段(文本段)
        映射 ELF 文件，包括文本常量和代码，是只读的段。
    - 数据段
        程序开始就已经初始化的静态和全局变量。
    - BSS段
        未初始化静态和全局变量。
    - 堆
    - MMAP段
    - 栈

- 内存分配相关系统调用与接口
    - brk()
    - mmap()
    - munmap()
    - malloc()
        - 空闲内存结构体，可用否，大小。
    - free()
    - alloc()

- 64 位系统与 32 位系统的不同
    主流 64 位地址实际上只用了 48 位。需要四层转换才能最终找到物理地址。支持 64TB 虚拟地址空间。
