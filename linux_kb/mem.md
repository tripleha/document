# linux 内存管理机制学习

(主要根据 32 位系统来学习)

- 分页与虚拟地址
    以字节为最小访问单位， 32 位地址理论上可以寻址 2<sup>32</sup>B(4GB) 的空间。不过这样虚拟地址和物理地址一一对应的话就要花费大量空间来存对应的映射关系，也缺乏连续性。所以采用分页的做法，将 32 位地址中的一部分低位数作为偏移的做法，这样将满足低位偏移确定空间大小作为一个页的大小，这样需要索引的只有页的首地址，接下来的页内偏移是虚拟地址和物理地址公用的。每页内存必须是连续的，才能使用偏移在页内定位。一般用的是12位的页内偏移。这样 4GB 的内存就被切成了一块块 2<sup>12</sup>B(4KB) 大小的空间。这样一共有 2<sup>20</sup> 个页。假设每个条目占用4字节(一个PTE)，则需要 4MB(2<sup>22</sup>B) 的连续物理内存空间存储页表映，地址前20位是页表中偏移(页号)。而且是对于单个进程而言，因为每个进程是不一样的，所以每个进程都需要 4MB 页表空间。这样的内存占用显然是不可以接受的。于是有了多级页表。
    - 多级页表
        我们对页号再做一层切分，分成两级页表，那么前十位对应一级页表的偏移，后十位对应二级页表的偏移，则我们一刚开始只需要 2<sup>12</sup>B (4KB) 的空间就可以了，然后根据需要的内存，再增加二级页表的数量，一共可以有 2<sup>10</sup> 个二级页表。总共可以映射 4GB 内存。那么我们就只需要一级页表的首地址，就可以解析任何一个虚拟地址了。
        |一级页号|二级页号|页内偏移|
        |--|--|--|
        |10位|10位|12位|
        - TLB(Translation Lookaside Buffer)
            多级页表下的一层缓存优化，又叫快表。如果虚拟地址在 TLB 中，则可以一步获得对应物理地址。
        - PTE(page table entry)
            因为物理内存分配是按页分配的，那么我们分配物理页面的首地址可以是后 12 位都是 0 的。这样物理内存管理也方便，并且页表条目 4B 可以只用 20位 存储物理地址开头，后 12 位可以按需存储一些页状态。

- 多任务系统下单个进程的用户空间(分段)
    linux 为了方便管理进程虚拟内存空间，划分内存空间功能，将内存分成一个个段，按段划分功能。
    用户空间由低地址到高地址分为:
    - 代码段(文本段)
        映射 ELF 文件，包括文本常量和代码，是只读的段。
    - 数据段
        程序开始就已经初始化的静态和全局变量。映射 ELF 文件内容。
    - BSS段
        未初始化静态和全局变量。用 0 覆盖。
    - 堆
    - MMAP段
        动态库， malloc 了的大内存。
    - 栈

- 内存分配相关系统调用与接口
    - mm_struct
        可以在 task_struct 中找到。是进程的内存空间描述符，存储了各段内存的起始和结束的虚拟地址和页数量，虚拟空间已用大小。mmap 字段存储 VMA 链表。mm_rb 是红黑树的根，用于快速找到 VMA 。
    - VMA (vm_area_struct)
        代表内存文件映射的内存空间的信息。没有具体的文件映射的 VMA 是匿名的。MMAP段可能被多个 VMA 切分管理。当调用段增加物理映射函数时 brk,mmap ，实际上内核只是创建或者更改 VMA ，只有等内存访问发生并引发错误，才会去检查对应的 VMA 上的权限，如果没有合适的说明真的访问非法内存了，然后引发段错误。否则则检查对应 PTE ，如果 PTE 是空白(没映射)则分配页物理内存，填补空白。
    - brk()
    - mmap()
    - munmap()
    - malloc()
        - 空闲内存结构体，可用否，大小。
    - free()
    - alloc()

- 64 位系统与 32 位系统的不同
    主流 64 位地址实际上只用了 48 位。需要四层转换才能最终找到物理地址。支持 64TB 虚拟地址空间。
