## C++ 编译过程相关

四个过程

    C++编译一共四个过程
    1.预编译(pre-processing):
        -E
        处理# 好开头的代码段
        如宏替换，还有将 # include 引入的头文件读取，并插入到程序文本中去等
    2.编译(compiling):
        -S
        该阶段由C++代码的编译器来负责，首先检查语法错误、代码规范性等问题
        然后将C++代码编译为汇编代码
    3.汇编(assembling):
        -c
        该阶段由汇编器将汇编代码转为二进制形式的可执行代码(机器码)
    4.链接(linking):
        符号重定位，将多个编译单元(库与目标文件)链接合并为一个可执行文件
        因为编译是以源文件为单位进行的，编译器此时并没有一个全局的视野，
        因此对一个编译单元内的符号它是无力确定其最终地址的，
        而对于可执行文件来说，在现代操作系统上，程序加载运行的地址是固定或可以预期的，
        因此在链接时，链接器可以直接计算分配该文件内各种段的绝对或相对地址。
        该步骤动态库与静态库的处理会有区别

静态库

    链接方式为 静态链接
    将静态库与汇编生成的目标文件链接为一个可执行文件
    程序运行时与函数库再无瓜葛(整合到了一起)，不需要有静态库文件才能运行，所以方便移植
    链接时符号重定位:
        有一个重定位表，记录了那些地方需要进行地址修正等，编译时给的是假地址
    使用:
        //
    缺点:
        浪费内存空间，因为静态库是整合在一起的，
            所以当运行这样一个程序时，静态库装载进内存占用4M空间的话，那么十个程序就是40M
            每个程序都有自己的那份，互相不共享。
        更新上的麻烦，因为一旦一个静态库有了更新，那么所有使用它的程序都要重新编译、下载才能获得更新，
            原本可能只是几行代码的改动，但是用户却需要把整个程序重新下载

动态库(共享库)

    链接方式为 动态链接
    与静态库相比，动态库把一些函数的链接载入推迟到了程序运行期间进行
        而多个程序可以共享一个动态库的代码空间
    动态链接器(本身不使用动态库，但是一个动态库)
        要做到运行时装载，那么对于动态库的符号，就需要进行重定位
        装载的推迟意味着重定位的推迟，所以符号重定位也是在程序运行时进行
        这个工作交由动态链接器来完成
        两种方式:
            1.加载时符号重定位
                与链接时符号重定位很像，不过在运行时无法对可执行文件的代码段进行符号重定位
                因此如果可执行文件引用了动态库中的数据符号，
                则在该可执行文件内对符号的重定位必须在链接阶段完成，
                为了做到这一点，会在可执行文件数据段先开出相应空间
                动态库的函数引用则采用延迟绑定的策略
            缺点:
                它不能使动态库的指令代码被共享。
                程序启动加载动态库后，对动态库中的符号引用进行重定位会比较花时间，
                    特别是动态库多且复杂的情况下。
            2.地址无关代码
                position independent code
                -fPIC
                通过对变量及函数的访问加一层跳转来实现
                模块内的符号访问:
                    只需要相对地址，而对于模块内数据，
                    由于没有直接根据当前代码地址和偏移寻址数据的寻址方式
                    所以用了一个小技巧:
                        call一个函数会将当前代码的下一条执行地址送入esp指向栈内存，
                        则call的那个函数简单的将esp指向内存送入ecx
                模块外的符号访问:
                    因为动态库未加载，所以无从得知地址，
                    则在数据段建立一个GOT(global offset table)，用于存放数据全局符号的地址
                    由动态库加载后让动态链接器初始化，动态库使用全局符号则到该表取出相应地址
                    (因为多了GOT这层跳转，所以性能会有损失)
                延迟绑定:
                    对于动态库，我们有时可能只需要用到其中的一小部分函数，所以没必要在装载时就全部重定位
                    将函数的重定位推迟到第一次调用时
                    建立一个GOT.PLT表用于存放全局函数的地址，
                    但最开始时放的不是一个真实地址，而是一个跳转(fun@plt中的第二条指令的地址)
                    fun@plt:
                        jmp *(fun@got.plt)
                        push index
                        jmp _init
                    所有对fun的调用换为对fun@plt的调用，
                    _init() 这个函数则用于把 fun 进行重定位，
                        然后把结果写入到 got.plt 相应的地方，最后直接跳过去该函数
                    这样子第一次调用时会执行完 _init()，然后got.plt的该函数的位置会填上对的值
                    之后的调用就会直接在jmp *(fun@got.plt)之后进入函数执行，然后返回之后就不会回到后面 _init()了
                    (每次外部函数调用会多一次跳转，有性能损失)
                PIC的好处是动态库的代码段可以完全共享，每个程序只需要维持自己的一份GOT就可以了
    使用:
        //
    linux下通过ldd命令可以查看一个可执行文件需要依赖哪些动态库
