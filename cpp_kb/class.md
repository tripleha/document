## C++ 面向对象特性

面向对象特性介绍

    封装性是基础，继承性是关键，多态性是补充

    class 定义对象
        一个对象实例，在无任何成员变量和虚函数的时候，仍会占有1字节的内存空间，用作占位。
    三类继承操作
        private
        protected
        public

        特殊的继承: 虚继承 virtual
        成员访问限制:
            注意:成员访问限制是在编译期进行的检查，
                直接采用指针操作可以绕开检查而访问私有成员等原来不可访问变量。

继承关系:

||public|protected|private
|-|-|-|-|
共有继承|public|protected|不可见
私有继承|private|private|不可见
保护继承|protected|protected|不可见

多态特性

    注意: 静态类型是无法实现多态的，因为多态需要在运行时分配内存，需要用指针来实现多态。
        对于静态类型，编译期就已经决定内存大小了，对于声明成基类的数据类型，会直接截取基类的内存部分
    在 64位 系统下，地址的空间是8个字节(long)(32位下是4字节(int))
    对于一个类型，其开头空间将会分配用于存放虚函数表的指针。
    虚函数表的前一个位置存放了指向Type_info指针，用以支持RTTI(运行时类型识别)
        其中包括了对象继承关系等与多态相关的信息
    
    在虚函数表指针空间之后，是非静态成员变量的空间。
    静态成员变量不在对象实例的内存空间中。
    对于函数，会替换成第一个参数为this指针的函数，实际上不需要存在对象的内存空间中。

    在不同的继承关系下，虚函数表的分布是不同的。

    一般继承:
        单继承:
            子类有自己的虚函数表，表首部是所有父类所拥有的虚函数指针的位置
            若重写了父类的虚函数，则覆盖该位置的函数指针
            若是子类新定义的虚函数，则添加在表末尾。
        多继承:
            子类将会有多个虚函数表空间，初始化为每个基类的虚函数
            子类的新虚函数将会放在声明的第一个基类的虚函数表中
            当重写时，所有的基类的虚函数表的同名方法都会重写
            对于内存空间，按照声明的基类顺序排列，子类空间加在最后
            如:
                C: A, B
                A虚函数表ptr
                A非static成员变量
                B虚函数表ptr
                B非static成员变量
                C非static成员变量
    虚继承:


内存对齐机制

    以 最大基础类型 为单元，最终大小必须是其整数倍
    且按照定义顺序，尽可能填满每个单元，但是绝对不会切分一个数据到不同单元用于填满，
    所以拥有同样的数据的类，成员定义顺序不同，最终类的大小也有可能不同。
