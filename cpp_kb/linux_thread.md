# C++使用linux线程知识

    linux进程
        进程在体系结构的概念中是资源管理单元，保护模式下，
        每个进程有着自己的内存地址空间，打开的文件，挂起的信号，进程状态等信息。
        task_struct即进程描述符，是系统用于管理进程的数据结构。(SLAB分配器)
        内核使用双向链表实现的任务队列来组织task_struct。使用PID来唯一标识一个进程。
        task_struct存有这些基本信息。包括父进程和子进程链表信息。

    进程从属关系

    fork() 函数 内部调用 clone()系统调用，其实进程的创建都是复制的过程，
    会根据传参决定子进程共享父进程的哪些资源。
        写时复制(copy)机制 COW
            在新进程创建时，子进程和父进程共享一个进程地址空间拷贝，即父子进程的物理内存空间是相同的
            只有当子进程或者父进程对这个拷贝执行写入操作时，
            即有相应的段更改时，才会为子进程相应的段分配物理空间
    exec() 函数完成可执行文件的读取
        执行该函数，则子进程将会读入新的执行文件，拥有自己的代码段，
        如果未执行该函数，则子进程使用父进程的代码段物理空间
    当子进程创建后，系统会将子进程放于队列前，使其先于父进程执行，防止因父进程的执行而先于子进程执行exec()触发写时复制
        所以fork的实际开销就是复制父进程页表和给子进程创建进程描述符。
    vfork() 函数，子进程将不拥有自己的地址空间，而是直接使用父进程的地址空间。

    linux中 内核级线程实际上是轻型进程

    pthread.h

    int pthread_create(pthread_t *__restrict__ __newthread, const pthread_attr_t *__restrict__ __attr, void *(*__start_routine)(void *), void *__restrict__ __arg)
        参数:
            __newthread 为线程号的内存地址，引用传入，线程开启完毕后相应内存会变为线程ID
            __attr 为线程的设置参数
            __start_routine 要执行的事务，为一个函数指针，该函数应仅接受一个参数
            __arg 执行的事务的参数

    由于linux下线程实际上也占用着进程表的资源，所以在若进程持续执行而不需要用到某些线程了，
    则需要手动回收线程资源。(当进程退出时开启的所有相关线程的资源都会全部回收)

    int pthread_join(pthread_t __th, void **__thread_return)
        因为每一个线程开启实际上是执行一个返回值为 void *的函数，所以可以通过join获取到该返回值
        参数:
            __th 为 线程号
            __thread_return 为 一个指针的地址
                若该传入地址不为NULL的话，就会向该地址写入返回值的指针

    int pthread_detach(pthread_t __th)
        若不关心线程的返回值，则可以直接调用这个，因为join是会阻塞调用的进程的，
        而detach是非阻塞的，经过detach调用后，相关线程退出将自动回收掉所有资源

    __thread 线程局部存储关键字，可以用于声明供每个线程使用的线程局部变量。
    除此之外还有线程特有变量，很繁琐，不推荐使用。

    可重入的概念，可重入即可以随时中断的函数，这种函数一般不依赖于全局变量区数据，所以可以重入。但是如果需要访问全局变量，则必须采用互斥手段来防止两次调用同时修改全局变量区数据。

    C++11 新引入的 thread 库
