## C++

把资源封装管理是一门艺术

前向声明，尽量减少自己头文件中的 include 依赖

## RAII or RRID

    让资源的持有时间与对象的生命周期绑定，C++的核心用法之一。
    资源在对象初始化时获取，在对象析构时释放。不止是内存资源，还可以是锁，打开的文件描述符等任何你可以定义的资源。
    std::lock_guard 采用 RAII 来控制互斥量
    std::ScopeGuard 采用 RRID 。是 RAII 的简化，构造时不需要获取资源，只是强调析构时会释放资源，释放资源的函数由用户定义。获取资源的步骤由用户自行完成。
    使用这种方法的好处是只要能够确保析构函数会被调用，则资源一定会被释放。所以可以用来对付异常而不需要 finally 来专门写释放资源的代码。

## c++ 基础操作

typedef 与 # define 与 using

    # 是 宏 # define 操作是宏定义，在编译前进行处理，宏定义的处理方式是直接替换
    typedef 不同于宏，其在编译阶段由编译器负责处理，功能完全覆盖宏定义的类型别名部分
        typedef void(*func)(); 对于函数指针类型的定义方式。

## sizeof

    sizeof 是在编译期完成的。它既不是函数也不是运算符，可以当成是一种特殊的宏。
    对于数组来说一般是可以直接确定其大小的，所以可以使用 sizeof(array) 来得到数组占用的字节数。
    但是如果对于形参的话，int[] 是无法表示一个数组的，实际上它被当作一个指针来对待，所以实际上是 sizeof(ptr)

    array 和 &array 的区别
    一个是引式转化，因为如果作为一个变量用，它代表的是一个数组，但是如果要查询其值，那就需要有个表示，所以将其定位为数组第一个元素的地址是合适的
    而 &array 实际上这里的 array 就变成变量了，代表的是一个数组，所以取地址的话就是取数组的首地址。

## 达夫设备

## std::function std::bind

## explicit
    要求构造函数必须显示类型初始化或者显示调用。用以抑制通过隐式类型转换来复制初始化。

## inline
    是一种对于编译器的建议，至于编译器是否要执行则由编译器自己决定。

## ^ 异或操作可以不用中间变量而交换两个整形的值
    a = a^b;
    b = a^b;
    a = a^b;
